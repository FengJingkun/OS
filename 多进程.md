## 进程和线程

### 引子

CPU的工作原理可以表示成下面这样的伪码：

```c++
while (PC) {
    取指 -> 析指 -> 执行 -> 写回;
    PC = PC + 1;
}
```

最初OS被设计成单道批处理系统。然而，CPU的运算速度要远远超过读写内存的时间。

```c++
void func_print() {
    for (int i = 0; i < 1000; ++i) {
        printf("print a message\n");
    }
}

void func_loop() {
    int sum = 0;
    for (int i = 0; i < 10000000; ++i)
        sum += i;
}
```

根据上述两函数的运行时间可以看出：**IO指令远远大于计算指令的执行时间。**在单道程序系统中，执行IO指令后，CPU必须处于等待状态，直至IO操作完成，这就导致CPU利用率的严重降低。 因此便有了程序在执行IO时，CPU切换至其他程序继续执行的设计，即**并发**。

<br>

### 进程

引入并发思想后，CPU在多段程序间切换执行，从而可以在IO等待时转去执行另一段程序，提高利用率。

然而，多个程序执行时不可避免地会读写同一寄存器。如果只是改变PC指针的指向来进行切换，那么当前程序的修改就会被其他程序覆盖，从而无法得到正确的执行结果。因此，一段程序需要附带一些数据信息，以便保存程序切换时的执行现场，进而保证并发执行的正确性。这种程序+数据的组合就是**进程。**

**进程用来描述一个程序及其执行过程中的信息，即描述一个执行中的程序，所以才将其命名为进程，即进行中的程序。**

特别地，引入**进程控制块PCB**来记录进程信息。**OS管理多进程的关键就在于管理各个进程的PCB**。

<br>

### 进程间的地址隔离

多个进程在内存中交替执行会提高CPU利用率，但也会带来一些问题。考虑下面两个进程：

```assembly
# proc1
mov ax, [100]
mov 1, ax

# proc2 (位于内存的50-150地址间)
mov [100], ax
```

二者位于用户态执行，此时CPL = DPL = 3，因此进程1可以对进程2所在的内存区域进行读写，从而导致进程2出错。为了解决该问题，引入了**地址隔离**。即，每个进程不操作实际的物理内存地址，而是通过一个映射表对应到物理地址。**这就是需要用到GDT表和页表来翻译CS:EIP的真实原因。**

**进程启动时，OS为其分配一段仅属于该进程的，互不重叠的物理内存，并通过映射表来建立映射，进而实现进程之间的地址隔离。这是OS进行内存管理的核心。**

<br>

### 进程间的通信与合作

多个进程同时放在内存中，需要隔离相互之间的影响，但有时也需要合作。**这就产生了进程间通信和同步的问题。**

<br>

### 线程 

**并发的基本含义是多段程序交替执行。**这种交替执行既可以发生在两段独立的程序间，也可以发生在同一个可执行文件内，如一段程序中的两个函数交替执行。这就引入了**线程**的概念。

**线程是在一个地址空间下启动并交替执行多个程序，交替执行的程序可以位于用户态(用户级线程)，也可以位于内核态(内核级线程)。后者由OS进行管理。**

<br>

### 用户级线程的切换

**用户级线程是完全在用户态内存中创建的一个指令执行序列。即用户级线程的TCB，栈等内容都是创建在用户态中的，对OS而言是透明的。**

线程切换是进程切换的核心。除了线程切换，进程切换还涉及到资源切换。这里先对用户级线程切换进行分析。

假设有两个用户级线程：线程1执行A函数，线程2执行C函数，并通过Yield函数完成切换：

```c++
// thread 1         |       // thread 2         |        // one stack
100: A() {          |       300: C() {          |           104
         B();       |                D();       |           204
104:     ...        |       304:     ...        |           304
     }              |            }              |           404
                    |                           |        // two stack
200: B() {          |       400: D() {          |        // stack1            stack2
         Yield();   |                Yield();   |           104               304 
204:     ...        |       404:     ...        |           204               404
     }              |            }              |        // tcb1 esp = 1000   tcb2 esp = 2000
```

首先进入A执行。

- 调用B时，**需要通过栈保存一些信息，以便B函数返回时A函数能继续执行。**因此需要先将返回地址104入栈。进入B执行后，调用Yield切换线程时，同样先将返回地址204入栈。

接下来执行Yield函数。

- 该函数需要找到下一个线程以及下一个线程在切换出去时的执行位置，并跳转到该位置。**由于线程位于同一地址空间，因此直接跳转即可。**

```c++
void Yield() {
    jmp 300; // A() -> B() -> Yield()
} // ret
```

跳转到线程2执行。

- 调用函数D，入栈304。然后在D中调用Yield，将404入栈。在Yield函数中，通过jmp跳转至204，然后PC将指向204继续取指执行。

**执行到B末尾的ret时，会弹栈进行函数返回。**但pop得到的地址却是404，而非104。**显然栈出了问题。**

**因此，尽管线程共享进程资源，每个线程依然需要有自己独立的栈来保证线程切换时的正确性。**

特别地，每个线程拥有自己的栈之后，切换时需要将栈一同切换，这就需要引入一种数据结构记录线程的相关信息，以及对应的栈地址，**即线程控制块TCB。**

使用两个栈继续往下执行。

- 此时Yield函数除了jmp，还应完成栈的切换。然而，**现在从函数B返回时，pop得到的却是204，仍非104。**对Yield分析可发现：切换栈后，将执行jmp跳转至204，Yield末尾的ret则**永远不会执行**，进而不会弹栈。对此，**只需要将jmp指令删掉，利用ret弹栈来实现跳转。**

```c++
void Yield() {
    ... ; // 寻找下一个线程的TCB
    tcb2.esp = 2000 // 将当前esp寄存器的值保存在当前线程的TCB中
    esp = nextThread.tcb.esp; // 将下一线程的esp赋给esp寄存器,完成栈的切换
    push ... ; // 保存当前线程的执行现场
} // ret: 弹栈, 切换至另一线程的指令序列
```

最后对用户级线程的切换进行总结：

1. **用户级线程的切换就是在切换位置上调用Yield函数**
2. **Yield函数需要寻找下一个线程的TCB，完成栈的切换，利用ret将PC指向下一线程的待执行指令位置**
3. **切换前入栈保存当前线程的执行现场，切换后弹栈恢复下一线程的执行现场**

<br>

### 用户级线程的创建

和进程一样，线程也是一段执行起来的程序，因此**创建线程实际就是将一段程序初始化成可以让CPU切换执行的样子，CPU的切入点就是该程序的首地址。**

为了创建线程，首先需要申请一段栈空间，将待执行线程的程序首地址入栈，并初始化执行现场，栈的地址也应保存在新线程的TCB中。此外，**除了要给thread_create传递新线程要执行的函数首地址外，还应给函数传递必要的参数。**

```c++
void thread_create(void* func, void* args) {
    long *stack = malloc(SIZE_OF_USERSTACK);
    TCB *p = malloc(SIZE_OF_TCB);
    *stack = args; // 传递func参数
    *(stack--) = thread_exit; // func执行完后通过系统调用thread_exit退出线程
    *(stack--) = func;
    *(stack--) = eax; // 初始化func执行现场,可以全是0
    p->esp = stack;
}
```

<br>

### 函数栈帧

讨论线程主函数的参数如何设置之前，先讨论C语言函数的参数是如何工作的：

```c++
int s = 0;                    //     sum:
int sum(int x, int y) {       //         push %ebp                |   高地址
    int t = x + y;            //         movl %esp, %ebp          |
    s += t;                   //         movl 12(%ebp), %eax      |
}                             //         addl 8(%ebp), %eax       |
                              //         addl %eax, s             |   
int main() {                  //         popl %ebp                |
    sum(2, 3);                //         ret                     \|/  低地址
}
```

根据sum函数的汇编码可以看出：

- sum的参数通过入栈来进行传递
- sum开始时，将main的ebp入栈保存，然后将esp赋值给ebp，此时**当前ebp与主函数ebp之间就构成了一个栈帧**
- sum刚开始执行时，通过EBP寄存器 + 偏移值从栈中取参数
- 新的ebp即为sum函数栈帧的栈底，此时sum第一个参数存放在ebp + 8处，第二个存放在ebp + 12处

相应地，**在main函数中**，只需要在栈中依次放入第二个参数，第一个参数和sum函数的返回地址，并将esp指向存放返回地址的内存单元即可。完成这些设置后，进入sum函数后就能自动获取对应参数了。

**因此，在thread_create函数中，需要向新线程的栈中依次存放函数参数，函数返回地址(thread_exit)，函数地址。**当其他线程调用Yield切换至新线程执行时，Yield的ret指令弹栈获取到新线程开始执行的函数地址，然后在新函数执行时，保存thread_create的ebp，并将esp赋值给ebp，接下来通过ebp的偏移来获取**在thread_create栈帧中保存的函数参数。**新线程就开始投入执行了。

<br>

### 内核级线程

用户级线程有时需要通过系统调用进入内核态。如在浏览器进程中，GetData线程会通过网卡向网站发出数据下载请求，该过程需要在内核中完成。GetData在数据到达之前陷入等待状态，CPU会切换执行**其它进程**。然而，此时浏览器进程的其它线程可能仍处于可执行状态，但由于这些线程处于用户态，TCB等信息也保存在用户态，所以OS无法感知到它们的存在，更不可能切换执行它们。所以，**如果一个用户级线程在内核阻塞，那么该进程的所有线程将全部阻塞，进而限制用户级线程的并发程度。**这就引入了内核级线程。

**内核级线程是用户态内存和内核态内存合作创建的一个指令执行序列，内核级线程的TCB等信息在内核中创建，因此OS可以感知并操纵内核级线程。**

 <br>

### 内核级线程的切换

如前所述，用户级线程的切换可分为三步：TCB切换，根据TCB中保存的栈指针切换用户栈，Yield根据用户栈压入的函数返回地址完成PC指针切换。

显然，内核级线程的切换也需要完成上述三步。由于内核级线程的TCB保存在内核中，**因此需要进入内核完成切换。**具体地，内核级线程通过**中断**从用户态进入内核态，进而完成切换。特别地，**在切换内核栈时，需要将内核级线程在用户态内存中的用户栈同时切换。**

- **与用户级线程对比**
  - 用户级线程切换的核心是根据存放在TCB中的用户栈地址完成用户栈的切换，整个切换过程由Yield引发
  - 内核级线程切换的核心是首先进入内核中找到TCB，进而根据TCB存放的内核栈地址完成内核栈和用户栈的切换，整个切换过程由中断引发

下面从中断开始对内核级线程的切换过程进行分析：

**调用int中断指令，由用户栈切换到内核栈**

为了在中断返回至用户栈能接着执行，需要建立内核栈与用户栈的联系。具体地，将用户栈的的栈顶SS:ESP和标志寄存器EFLAGS压入内核栈，同时压入线程在用户态的执行位置CS:EIP。此外，**中断处理程序systemcall的开始处对用户态的执行现场进行保存。**

**调用schedule，引起TCB切换**

通过内核的全局变量current将指向当前线程的TCB状态修改为阻塞，并将TCB加入对应阻塞事件的等待队列。然后利用next指针指向待切换的TCB。

**切换内核栈**

```c++
current->TCB->esp = ESP;
ESP = next->TCB->esp;
```

**中断返回**

在新线程的内核栈中，中断处理程序将用户栈的执行现场恢复。

**用户栈切换**

将CS:EIP指向用户态的执行位置，将SS:ESP指向用户栈，具体通过iret完成。