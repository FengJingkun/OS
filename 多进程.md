## 进程和线程

### 引子

CPU的工作原理可以表示成下面这样的伪码：

```c++
while (PC) {
    取指 -> 析指 -> 执行 -> 写回;
    PC = PC + 1;
}
```

最初OS被设计成单道批处理系统。然而，CPU的运算速度要远远超过读写内存的时间。

```c++
void func_print() {
    for (int i = 0; i < 1000; ++i) {
        printf("print a message\n");
    }
}

void func_loop() {
    int sum = 0;
    for (int i = 0; i < 10000000; ++i)
        sum += i;
}
```

根据上述两函数的运行时间可以看出：**IO指令远远大于计算指令的执行时间。**在单道程序系统中，执行IO指令后，CPU必须处于等待状态，直至IO操作完成，这就导致CPU利用率的严重降低。 因此便有了程序在执行IO时，CPU切换至其他程序继续执行的设计，即**并发**。



### 进程

引入并发思想后，CPU在多段程序间切换执行，从而可以在IO等待时转去执行另一段程序，提高利用率。

然而，多个程序执行时不可避免地会读写同一寄存器。如果只是改变PC指针的指向来进行切换，那么当前程序的修改就会被其他程序覆盖，从而无法得到正确的执行结果。因此，一段程序需要附带一些数据信息，以便保存程序切换时的执行现场，进而保证并发执行的正确性。这种程序+数据的组合就是**进程。**

**进程用来描述一个程序及其执行过程中的信息，即描述一个执行中的程序，所以才将其命名为进程，即进行中的程序。**

特别地，引入**进程控制块PCB**来记录进程信息。**OS管理多进程的关键就在于管理各个进程的PCB**。



### 进程间的地址隔离

多个进程在内存中交替执行会提高CPU利用率，但也会带来一些问题。考虑下面两个进程：

```assembly
# proc1
mov ax, [100]
mov 1, ax

# proc2 (位于内存的50-150地址间)
mov [100], ax
```

二者位于用户态执行，此时CPL = DPL = 3，因此进程1可以对进程2所在的内存区域进行读写，从而导致进程2出错。为了解决该问题，引入了**地址隔离**。即，每个进程不操作实际的物理内存地址，而是通过一个映射表对应到物理地址。**这就是需要用到GDT表和页表来翻译CS:EIP的真实原因。**

**进程启动时，OS为其分配一段仅属于该进程的，互不重叠的物理内存，并通过映射表来建立映射，进而实现进程之间的地址隔离。这是OS进行内存管理的核心。**

 

### 进程间的通信与合作

多个进程同时放在内存中，需要隔离相互之间的影响，但有时也需要合作。**这就产生了进程间通信和同步的问题。**



### 线程 

**并发的基本含义是多段程序交替执行。**这种交替执行既可以发生在两段独立的程序间，也可以发生在同一个可执行文件内，如一段程序中的两个函数交替执行。这就引入了**线程**的概念。

**线程是在一个地址空间下启动并交替执行多个程序，交替执行的程序可以位于用户态(用户级线程)，也可以位于内核态(内核级线程)。后者由OS进行管理。**



### 用户级线程的切换

线程切换是进程切换的核心。除了线程切换，进程切换还涉及到资源切换。这里先对用户级线程切换进行分析。

假设有两个用户级线程：线程1执行A函数，线程2执行C函数，并通过Yield函数完成切换：

```c++
// thread 1         |       // thread 2         |        // one stack
100: A() {          |       300: C() {          |           104
         B();       |                D();       |           204
104:     ...        |       304:     ...        |           304
     }              |            }              |           404
                    |                           |        // two stack
200: B() {          |       400: D() {          |        // stack1            stack2
         Yield();   |                Yield();   |           104               304 
204:     ...        |       404:     ...        |           204               404
     }              |            }              |        // tcb1 esp = 1000   tcb2 esp = 2000
```

首先进入A执行。

- 调用B时，**需要通过栈保存一些信息，以便B函数返回时A函数能继续执行。**因此需要先将返回地址104入栈。进入B执行后，调用Yield切换线程时，同样先将返回地址204入栈。

接下来执行Yield函数。

- 该函数需要找到下一个线程以及下一个线程在切换出去时的执行位置，并跳转到该位置。**由于线程位于同一地址空间，因此直接跳转即可。**

```c++
void Yield() {
    jmp 300; // A() -> B() -> Yield()
} // ret
```

跳转到线程2执行。

- 调用函数D，入栈304。然后在D中调用Yield，将404入栈。在Yield函数中，通过jmp跳转至204，然后PC将指向204继续取指执行。

**执行到B末尾的ret时，会弹栈进行函数返回。**但pop得到的地址却是404，而非104。**显然栈出了问题。**

**因此，尽管线程共享进程资源，每个线程依然需要有自己独立的栈来保证线程切换时的正确性。**

特别地，每个线程拥有自己的栈之后，切换时需要将栈一同切换，这就需要引入一种数据结构记录线程的相关信息，以及对应的栈地址，**即线程控制块TCB。**

使用两个栈继续往下执行。

- 此时Yield函数除了jmp，还应完成栈的切换。然而，**现在从函数B返回时，pop得到的却是204，仍非104。**对Yield分析可发现：切换栈后，将执行jmp跳转至204，Yield末尾的ret则**永远不会执行**，进而不会弹栈。对此，**只需要将jmp指令删掉，利用ret弹栈来实现跳转。**

```c++
void Yield() {
    ... ; // 寻找下一个线程的TCB
    tcb2.esp = 2000 // 将当前esp寄存器的值保存在当前线程的TCB中
    esp = nextThread.tcb.esp; // 将下一线程的esp赋给esp寄存器,完成栈的切换
    push ... ; // 保存当前线程的执行现场
} // ret: 弹栈, 切换至另一线程的指令序列
```

最后对用户级线程的切换进行总结：

1. **用户级线程的切换就是在切换位置上调用Yield函数**
2. **Yield函数需要寻找下一个线程的TCB，完成栈的切换，利用ret将PC指向下一线程的待执行指令位置**
3. **切换前入栈保存当前线程的执行现场，切换后弹栈恢复下一线程的执行现场**