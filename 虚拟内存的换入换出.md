## 虚拟内存的换入换出

每个进程拥有一段规整独立的地址空间(虚拟内存)，进程可以访问该地址空间的任意地址。

由于实际的物理内存可能要小于进程的地址空间，因此虚拟内存不可能全部映射到物理内存上，进而导致**换入换出现象。**

<br>

## 请求调页

段页式内存机制的地址转换过程可分为两步：第一步根据逻辑地址获得段号，并查找段表获得虚拟地址；第二步根据虚拟地址获得虚拟页号，查找页表获得物理页地址。

由于进程的虚拟地址空间可以随意使用，因此**第一步一定可以完成。**然而，由于并不是所有的虚拟页都和物理页建立了关联，因此第二步就可能出现页表中未找到相应物理页的情况。具体实现中，MMU会查看页表项的有效位，根据有效位判断当前的虚拟页是否映射到物理内存上。这就引入了**内存换入问题。**

**内存换入的核心就是在产生缺页异常的时候请求调页，OS实现换入就是实现请求调页。**

具体地，MMU未找到对应物理页时，会产生**缺页中断**。CPU处理并返回中断后，**产生缺页中断的那条指令会被重新执行，这是因为该指令在执行中途发生了中断。**再次执行指令时，显然可以通过段表和页表找到对应的物理地址。至此，换入过程全部完成。

<br>

### 页面换入的具体实现

页面调入的具体实现从缺页中断的处理函数开始：

```c++
void trap_init(void) {
    // 页错误的中断号为14，由硬件电路决定
    set_trap_gate(14, &page_fault);
}
```

在汇编代码中，首先获取导致页错误的类型，判断是**缺页异常还是越权读写**，并将错误类型压入内核栈。

```assembly
page_fault:
	xchgl %eax, (%esp) # 将错误类型取出并赋给eax
	push %edx, %eax # 为即将调用的处理函数传参数
	if 错误类型为缺页
		call do_no_page
	else 
		call do_wp_page # 越权读写, 执行写保护
	iret
```

页换入由函数do_no_page完成

```c++
void do_no_page(unsigned long error_code, unsigned long address) {
    address &= 0xfffff00; // 计算虚拟页号
    page = get_free_page(); // 申请物理页
    bread_page(page, current->executable->i_dev, nr); // 磁盘读
    put_page(page, address); // 填写页表, 完成映射
}
```

<br>

## 页面换出

页面在换入时不会总能从物理内存中找到空闲的物理页，此时就需要从现有已映射的物理页中换出一页，腾出空闲页后再进行换入操作。具体地，**页面换出算法**用来选择要换出的页面。