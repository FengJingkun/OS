## 程序重定位

程序编译后生成可执行文件，其中用到的地址都是**逻辑地址**。可执行文件被载入物理内存后，需要根据**物理基址将逻辑地址转换成实际的物理地址**。这就是**程序重定位。**

- **编译时重定位**

  程序编译时进行重定位，但程序运行时载入的物理内存位置不固定，因此无法适用于日常的PC机上。

- **载入时重定位**

  程序载入时，根据载入的物理地址来修改程序中的逻辑地址，进而实现重定位。但在进程换入换出后，先前修改的地址就会失效，导致进程无法正常工作。

- **运行时重定位**

  在指令执行前完成逻辑地址到物理地址的转换。即**每执行一条指令，就将指令中的逻辑地址加上当前的物理基址以后再放到地址总线上。**由于每条指令都要进行地址转换，因此该过程由**硬件实现，即内存管理单元MMU。**

OS中往往运行着多个进程，每个进程被载入到不同的物理内存区域，因此拥有不同的物理基址。这些物理基址保存在PCB中，进程切换时从PCB中取出并赋值给基址寄存器。随后，MMU利用该寄存器完成**地址转换。**

**基址对应于一段内存空间，切换基址实际上就是切换一段内存空间。与线程切换相比，进程切换实际上只是多了地址空间的切换。**

<br>

## 分段

程序由若干段组成，每个段从0地址开始单独编址。其中，代码段由程序指令形成，为只读段；数据段存放程序使用的数据，可读可写；栈段用来实现函数调用，通常由高地址向低地址增长。

采用**分段机制**后，将程序载入内存时，应对每个段分别进行处理，即每个段载入不同的内存区域，因此需要记录每个段的基址，**这就引入了段表。**

使用段表后，地址就表示成**段号: 段内偏移**这样的基本格式。其中，程序中的逻辑地址就是段内偏移。此时地址转换的过程为：根据段号查找段表，获取当前段的基址，再通过基址 + 偏移地址计算实际的物理地址。

<br>

## 内存分区

程序载入内存时，首先需要分割出一段空闲的内存区域。**即针对一个段请求，OS从当前的空闲内存区域中寻找大于请求尺寸的内存区域，然后在该区域中划分出一块与请求尺寸大小相等的内存区域进行分配。**

进程在启动和退出时会申请和释放内存，这就容易产生**内存碎片：空闲内存由一堆分散在物理内存多个位置的小区域组成，尽管总区域很大，但由于无法满足单个段的尺寸请求而无法使用，进而造成空间浪费。**

OS可以通过移动将零散的空闲区域合并成一整块内存区域，即**内存紧缩**。但由于开销过大而无法实际使用。

为了缓解内存碎片问题，可以**将内存划分为固定大小的页。**当进程申请内存时，首先根据请求尺寸计算要分配的页数，然后在空闲内存区域的**任意位置**找出等量的内存页，将其分配给进程。这就是**内存分页机制。**

<br>

## 分页

分页机制将物理内存分割成固定大小的页，然后将请求放入物理内存的数据分割成固定大小的页，最后将所有数据页载入至离散的物理页中，并通过页表建立数据页与物理页的映射。

**分页机制下的重定位**

根据逻辑地址获取页号和偏移地址，根据页号查找页表获取物理页基址，最后通过物理基址 + 偏移地址完成地址转换。

**多级页表**

物理页的大小通常设置为4KB。32位机器的最大寻址空间为4GB，可以产生2^32 / 2^12 = 2^20个页表项。一个页表项通常需要4个字节来存储，因此一个页表需要占据4 × 2^20B = 4MB空间，即**每个进程的页表都需要占用4MB空间。**若为64位机器，则需要花费更多的空间。

根据**局部性原理**，进程执行时通常只会使用4GB逻辑空间中的少数几个逻辑页，因此在内存中只需要放入几个页表项即可，从而解决页表占用空间过大的问题。

然而，此时页表中的逻辑页号不再连续，这会耗费更多的页表项查找时间。即使使用二分法，根据逻辑页号查找物理页号也需要O(logN)次。因此，为了即不用在物理内存中存储没有建立映射的页表项，又保证页表中的逻辑页号连续，引入了**多级页表。**

**多级页表中引入了页目录项，每个页目录项包含多个页号连续的页表项，页表项映射了一页内存，而页目录项映射了多个连续页组成的一块内存。**

此时内存中存在多个表：由页目录项组成的页目录表，由页表项组成的页表。当根据逻辑页号查找对应的物理页时，先查找页目录表找到页目录项，然后根据页目录项中存放的指针找到页表，再从页表中找到逻辑页号对应的页表项，获取物理页号。

多级页表解决了页表占用内存过大以及页表号不连续导致的查找效率低下的问题，但会增加地址转换的时间。若为二级页表，则需要进行两次地址转换。为了解决该问题，引入了**快表**。

**快表由硬件电路实现，又称为TLB。**查找物理页时，先查TLB，若命中则结束查找，否则查找多级页表，并更新TLB。

<br>

**总结**

- 物理内存分页后，以页为单位进行内存分配，解决了内存碎片问题；
- 分页后需要页表完成地址转换，但会引入页表占用内存过大的问题；
- 引入多级页表可以在不降低页表项查找时间的前提下解决页表占用内存大的问题，但会降低地址转换的效率；
- 引入快表提高地址转换的效率。

<br>

## 段页式内存管理

对于程序而言，使用分段机制将程序分成若干段，每段独立编址，单独处理；而对于物理内存而言，使用分页机制可以避免内存碎片的产生，提高空间利用率。因此，有必要设计一种中间结构将分段和分页结合在一起，这就是**段页式内存管理。**特别地，中间结构即**虚拟内存。**

在虚拟内存中，一方面，分割出一些区域与程序的每个段建立映射；另一方面，虚拟内存被分割成页，并建立与物理页的映射。采用段页式内存管理机制后，将程序载入物理内存时，会依次完成如下工作：

- 程序分段后放入虚拟内存，由于后者没有与物理内存对应，因此仅在段表中记录程序段载入的虚拟内存基址；
- 虚拟内存中存放的“页内容”放入空闲物理页。由于虚拟内存并未存放真实数据，因此实际放入的是程序段内容；
- 建立页表来记录虚拟内存页和物理内存页间的映射关系。

当进行地址转换时，会依次完成如下工作：

- 根据逻辑地址得出虚拟段号和偏移地址，查找段表，得到程序段存放在虚拟内存的基地址，然后通过段基址 + 偏移地址获得虚拟地址；
- 根据虚拟地址和页长计算出虚拟页号和偏移地址，查找页表，得到物理页号，然后通过物理页基址 + 偏移地址获得物理地址。

